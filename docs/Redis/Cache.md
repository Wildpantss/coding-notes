# Redis缓存相关问题

*Redis* 基于内存, 读写速度很快, 因此经常用其作为数据库的 **缓存**。

- [Redis缓存相关问题](#redis缓存相关问题)
  - [缓存雪崩](#缓存雪崩)
  - [缓存击穿](#缓存击穿)
  - [缓存穿透](#缓存穿透)

## 缓存雪崩

通常我们为了保证 *Cache* 中的数据与 *Database* 中的数据一致性, 会给 *Redis* 中的数据设置 **过期时间**, 当缓存过期后就会重新访问数据库并将数据更新到 *Redis* 缓存中。

**缓存雪崩**: 在 **高并发** 的场景下, 如果**大量缓存数据在短时间内集中过期(失效), 或Redis发生宕机**, 所有的请求都会直接访问数据库, 从而导致数据库压力激增, 可能导致系统崩溃。

缓存雪崩的诱因有 **集中过期** 和 **Redis宕机**, 面对两种不同的原因也需要不同的解决方案:

**大量数据同时过期(Expire)**:

- 均匀设置过期时间:

  在设置 *key* 的 **过期时间** 的时候, 我们可以在一定范围内添加一个 **随机的偏移值**, 减少大量 *key* 在同一时间过期的可能性。

- 互斥锁

  我们也可以对数据库的访问加上一个 **互斥锁(Mutex)**, 这样当缓存失效时, 同一时间 **仅有一个链接能够访问数据库并构建缓存**, 缓存更新完毕后再释放互斥锁, 之后其他的链接都可以访问缓存来获得数据。

  > 这个互斥锁最好带有超时自动释放机制, 如果发生某些意外导致获取锁的链接一直阻塞, 整个系统都会被其阻塞。

- 后台更新缓存

  业务线程不负责更新缓存, 也不设置 *key* 的过期时间, **缓存过期的维护交由一个后台线程维护**。

  如果使用后台更新缓存, 还能够方便的实现 **缓存预热**。

  > Q: 那么后台线程如何知晓 key 失效?
  >
  > A: 轮询 / 通过消息队列被业务线程通知

**Redis故障宕机**:

- 服务熔断或请求限流
  
  当 *Redis* 宕机的时候, 我们可以采用 **限流机制, 拒绝部分访问, 暂时减少入站请求数量**, 减轻数据库的压力。(或者 **也可以直接服务熔断暂时拒绝所有的访问**)

- 构建 Redis 高可用集群
  
  服务熔断或者请求限流是宕机后的抢救措施, 实际上我们最好通过主从节点 **构建高可用的 *Redis* 集群来保证可靠性**。(主节点宕机后可以人工或者通过哨兵机制切换从节点成为主节点)

## 缓存击穿

我们的业务通常会有几个数据会被频繁地访问, 比如秒杀活动, 这类被频地访问的数据被称为 **热点数据**。

如果缓存中的某个 **热点数据过期**, 此时又刚好有大量的请求访问了该热点数据, 缓存不命中, 于是 **大量的请求直接访问数据库**, 数据库很容易就被高并发的请求冲垮, 这就是缓存击穿的问题。

> 可以理解为缓存击穿是 [缓存雪崩](#缓存雪崩) 中的一种特殊情况

缓存击穿的解决方案和 [缓存雪崩](#缓存雪崩) 类似, 可以采取:

- 互斥锁: 仅有一个链接能够访问数据库
- 后台线程更新: 由后台线程判断缓存是否应该过期

## 缓存穿透

当发生 [缓存雪崩](#缓存雪崩) 或 [缓存击穿](#缓存击穿) 时, 数据库中还是保存了应用要访问的数据, 一旦缓存恢复相对应的数据, 就可以减轻数据库的压力, 但缓存穿透就不一样了。

当 **用户访问的数据既不在缓存中也不在数据库中**, 请求在访问缓存时发现缓存缺失, 再去访问数据库时, 又发现数据库中也没有要访问的数据, 于是没办法构建缓存数据来服务后续的请求。那么当有大量这样的请求到来时, 缓存层就像不存在了一样, 所有的请求都打在了数据库上, 数据库的压力骤增, 这就是缓存穿透的问题。

缓存穿透的原因一般有以下两种:

- 业务误操作, 缓存中的数据和数据库中的数据都被 **误删除** 了, 所以导致缓存和数据库中都没有数据。
- **恶意攻击**, 故意制造大量访问某些不存在数据的请求。

应对缓存穿透, 常见的解决方案如下:

- 限制非法请求

  在 *API* 入口处校验拦截非法参数的请求, 过滤恶意请求, 避免进一步访问缓存和数据库。

- 缓存空值 / 默认值

  业务上线后发现缓存穿透的现象后, 我们可以针对被查询的数据, **在缓存中放入空值或者默认值**, 从而避免大量请求访问数据库。

- 使用 [**布隆过滤器(*Bloom-Filter*)**](./Bloom-Filter.md) 快速判断数据是否存在
  
  布隆过滤器(*Bloom-Filter*) 是一种特殊的数据结构, 能够在 *O(1)* 的时间复杂度内判断一个 *key* 是否存在, 使用布隆过滤器能够将避免访问数据库中不存在的数据。

  > 查询布隆过滤器说数据存在, 并不一定代表数据库中存在这个数据。但是查询到数据不存在, 数据库中一定就不存在这个数据。
